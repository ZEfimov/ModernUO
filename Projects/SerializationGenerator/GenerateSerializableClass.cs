/*************************************************************************
 * ModernUO                                                              *
 * Copyright (C) 2019-2021 - ModernUO Development Team                   *
 * Email: hi@modernuo.com                                                *
 * File: GenerateSerializableClass.cs                                    *
 *                                                                       *
 * This program is free software: you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation, either version 3 of the License, or     *
 * (at your option) any later version.                                   *
 *                                                                       *
 * You should have received a copy of the GNU General Public License     *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *************************************************************************/

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Humanizer;
using Microsoft.CodeAnalysis;

namespace SerializationGenerator
{
    public static class GenerateSerializableClass
    {
        public static void GenerateClassHeader(this StringBuilder source, string namespaceName, string className, int version)
        {
            source.AppendLine(
                $@"/// <auto-generated />
using System;
using System.Collections.Generic;
using System.IO;

namespace {namespaceName}
{{
    public partial class {className}
    {{
        private const int _version = {version};
"
            );
        }

        public static void GenerateClassFooter(this StringBuilder source)
        {
            source.AppendLine(@"    }
}
");
        }

        public static void GenerateSerialCtor(this StringBuilder source, string className)
        {
            source.AppendLine($@"        public {className}(Serial serial)
        {{
            Serial = serial;
            SetTypeRef(GetType());
        }}");
        }

        public static void GenerateSerialCtorOverride(this StringBuilder source, string className)
        {
            source.AppendLine($@"        public {className}(Serial serial) : base(serial)
        {{
        }}");
        }

        public static void GenerateProperty(
            this StringBuilder source,
            IFieldSymbol fieldSymbol,
            ISymbol serializableFieldAttribute
        )
        {
            var allAttributes = fieldSymbol.GetAttributes();

            var hasAttribute = allAttributes
                .Any(
                    attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, serializableFieldAttribute)
                );

            if (!hasAttribute)
            {
                return;
            }

            // get the name and type of the field
            var fieldName = fieldSymbol.Name;
            var fieldType = fieldSymbol.Type;

            var propertyName = fieldName;

            if (propertyName.StartsWith("m_", StringComparison.OrdinalIgnoreCase))
            {
                propertyName = propertyName.Substring(2);
            }
            else if (propertyName.StartsWith("_", StringComparison.OrdinalIgnoreCase))
            {
                propertyName = propertyName.Substring(1);
            }

            propertyName = propertyName.Dehumanize();

            foreach (var attr in allAttributes)
            {
                if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, serializableFieldAttribute))
                {
                    continue;
                }

                if (attr.AttributeClass == null)
                {
                    continue;
                }

                source.GenerateAttribute(attr);
            }

            source.AppendLine($@"        public {fieldType} {propertyName}
        {{
            get => {fieldName};
            set
            {{
                if (value != {fieldName})
                {{
                    MarkDirty();
                    {fieldName} = value;
                }}
            }}
        }}
");
        }

        public static void GenerateAttribute(this StringBuilder source, AttributeData attr)
        {
            source.Append($"        [{attr.AttributeClass?.Name}");
            var ctorArgs = attr.ConstructorArguments;
            var namedArgs = attr.NamedArguments;
            var hasArgs = ctorArgs.Length + namedArgs.Length > 0;

            if (hasArgs)
            {
                source.Append("(");
            }

            if (hasArgs)
            {
                source.Append(")");
            }

            for (var i = 0; i < ctorArgs.Length; i++)
            {
                var arg = ctorArgs[i];
                source.GenerateTypedConstant(arg);
                if (i < ctorArgs.Length - 1)
                {
                    source.Append(", ");
                }
            }

            for (var i = 0; i < namedArgs.Length; i++)
            {
                var arg = namedArgs[i];
                source.GenerateNamedArgument(arg);
                if (i < namedArgs.Length - 1)
                {
                    source.Append(", ");
                }
            }

            source.AppendLine("]");
        }

        public static void GenerateNamedArgument(this StringBuilder source, KeyValuePair<string, TypedConstant> namedArg)
        {
            source.AppendFormat("{0} = ", namedArg.Key);
            source.GenerateTypedConstant(namedArg.Value);
        }

        public static void GenerateArrayValueTypedConstants(this StringBuilder source, ImmutableArray<TypedConstant> args)
        {
            source.Append('{');
            for (var i = 0; i < args.Length; i++)
            {
                source.GenerateTypedConstant(args[i]);
                if (i < args.Length - 1)
                {
                    source.Append(", ");
                }
            }
            source.Append('}');
        }

        public static void GenerateTypedConstant(this StringBuilder source, TypedConstant arg)
        {
            if (arg.IsNull)
            {
                source.Append("null");
                return;
            }

            switch (arg.Kind)
            {
                default:
                    {
                        return;
                    }
                case TypedConstantKind.Primitive:
                    {

                        if (arg.Value is string str)
                        {
                            source.AppendFormat("\"{0}\"", str);
                        }
                        else
                        {
                            source.Append(arg.Value);
                        }
                        break;
                    }
                case TypedConstantKind.Enum:
                    {
                        source.AppendFormat("{0}.{1}", arg.Type?.Name, arg.Value);
                        break;
                    }
                case TypedConstantKind.Type:
                    {
                        source.AppendFormat("typeof({0})", ((ITypeSymbol)arg.Value)?.Name);
                        break;
                    }
                case TypedConstantKind.Array:
                    {
                        source.GenerateArrayValueTypedConstants(arg.Values);
                        break;
                    }
            }
        }
    }
}
